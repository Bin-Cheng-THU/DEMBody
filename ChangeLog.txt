********************************************************************
该文件夹下用于程序开发相关版本。

即更新代码功能，上传Git，加入程序发布说明

相关的测试文件存储于BenchMark文件夹中，生成的动画存储于动画汇总中。
*********************************************************************
Git命令步骤

git status 查看修改；git add -A 添加修改至暂存区
git commit -m 添加修改至存储区； git push origin master 发布修改
*********************************************************************
DEMBody   2.0

加入编译预处理，其中包括NMAX设置，场景设置，接触类型选择，网格划分。
优化代码架构，分为src文件，存储源码与make file
                  input文件，存储输入信息
                  data文件，存储输出数据
使用程序需修改输入文件，修改makefile中的模型设置，修改system control。
*********************************************************************
DEMBody   2.0

加入BondedWall功能，当前版本仅有长方形单元，用于实现多面体的运动计算；
优化代码架构，加入tool文件夹，用于存储前、后处理相关程序，包括网格划分工具、
              加入Data/Wall文件夹，用于存储BondedWall的vtk文件（程序控制）。
*********************************************************************
DEMBody   3.0    27/3/2018上线

全新的网格搜索算法，在50万基准颗粒测试中提升效率一千倍。
增加benchmark基准测试输入与控制文件。
增加genMesh文件，用于辅助网格算法。
*********************************************************************
DEMBody   4.0    21/5/2018上线

引力模块：（仍需更新）
    加入自引力计算模块，使用makefile预处理self_gravity控制。
    修复了GravityLattice中的相关bug，精细化了引力计算过程，但效率有所降低。
    设置独立的引力计算步长、修正引力计算结果以提高效率与精确度（待完成）
    加入GravBody模块，用于生成中心小天体引力场以及接触受力，同时加入四元数描述
并行设置：
    修改了Lattice部分的算法，将其由数组转换为链表，大幅度提升了内存能力。（仍需更新）
    增加了对于Lattice更新的步长控制，考虑到颗粒移动速度与网格宽度，间隔几个步长之后再更新。（仍需更新）
    修复latticeGenerate中的相关bug；同时将其转为并行算法，牺牲了些许精度，但是大幅度提高了效率。
    修改了BodyForce的并行控制语言，大幅度提高了计算效率。
    减小了墙壁网格算法的阈值，由Dx => 0.8*Dx
其他：
    修改了颗粒对接触模型，在凝聚力区域增加正向阻尼力、切向阻尼力以及滚动阻尼力（暂未加），以提高接触强度。
    删除了颗粒对接触时，在凝聚力区域的相关作用力（即删除上个注释的工作），将模型修改为Jiang的最新模型，利用Beta、Mu与c描述系统。
    修改了periodic模型，以实现长方形的周期边界条件
后处理模块：
    加入Demo.pov，内置多种纹理
    更新genWallPOVRay.m，细化纹理操作与动画设置
加入ChangeLog.txt文件
加入Description.txt文件，以描述每次仿真的详细设置与所做出的源码修改，确保仿真工作的流程精细化。
*********************************************************************
DEMBody   4.1    25/9/2018上线

系统：
    调试通过Windows版本预编译指令，工程文件存入DEMBody文件夹，存储入git，以后可以直接使用该工程进行windows版本的调试。
    将forceLattice与forceTraverse的算法选择放入编译选项中设置；同时Lattice算法相关的函数也放入其中。
Lattice算法：
    测试稳定性，未发现问题，已解决【可能是时间步长设置问题】
    修改加速策略，参考ESyS-Particle，设置颗粒运动阈值，在颗粒运动范围超出限制后更新网格；注意经过测试发现并行确实会出现很多问题！！！【此加速策略要求，任何大范围的颗粒移动都需要网格刷新，因此运行周期边界之后需要更新网格！！！，此前Pan仿真的问题应该出在这个地方】
链表算法：
    链表算法存在较大问题，在跨网格时可能丢失接触信息，因此将压缩信息链表转换为全信息链表，即链表保存所有与其接触的颗粒数据；每次修改将对两条链表进行修改，但这样将会造成并行区域的问题，继续思考解决办法
    方案[1]：双链条读，单链条写，即写入接触信息原来存在的链表中，保证一定可以查阅到链条存储的相应信息，但是又不会存在双链条均有信息，找不到选取哪一条的情况；但是其实该方法还是存在并行问题，由于执行写入操作时有可能涉及到邻居网格的写入操作，影响到邻居颗粒链表，因而可能出现单个变量同时写入的情况！！！
        但经过分析之后发现，该情况只存在于HeadI没有HeadJ存在的情况，此时涉及到的操作只有修改或删除，其中修改无任何不良影响，而删除可能会影响其他网格的修改操作，即相邻线程同时在处理该颗粒的链表；这一修改操作包含修改（无影响）、增加（可能有影响，改变的节点位置相同）、删除（可能有影响，改变的节点位置相同）。
        若采用了verlet算法，由于网格更新的频率降低了，相当于发生这种错误的概率更加大大降低了。即必须为更新网格算法的同时，发生了颗粒更换接触顺序的情况，
    方案[2]：双链条读，单链条写，但是写入网格内颗粒对应的链条。此种方案显然可以保证并行写入时不会出现错误。但面临一个新的问题，即如何判断哪一个链条获得信息是正确的，一种简单的方法即是将时间信息保存在接触链表之中；如果该信息为上一时刻，那么即为最新的信息。总结一下，即为读取信息从两条链表中找到最新的，写入链表的时候只操作particleI对应的链表。
    经过测试，方案[1]与方案[2]均可实现较长时间的计算稳定，最终选择方案[2]作为解决方案（1000步运算之后，3000颗粒的受力误差和不超过0.2）。
    再次发现问题：读取的时候也可能出现别的线程正好在更新链表的情况。因此应尽可能减小访问其他单元内的链表信息，即particleJ的信息。设置如下措施，[1]，若particleI链表中已访问到数据，则不访问particleJ链表；[2]，颗粒脱离时不删除数据，只将其从链表节点中删除(可能会有很大的问题，后续将修改为双链表分离操作！！！)
    最终方案：经过仔细研究与测试，我们发现采用现行的半搜索方案可能无法处理线程冲突的问题，而之前的经验告诉我们设置critical区的效率非常低，因此最终采用全搜索的方式。
    全搜索链表：将LatticeGenerate算法修改为全邻居颗粒产生；同时forceLattice中计算受力只更新particleI，同时去除reduction。
    经input_points_Lattice测试发现新的Lattice算法在30万超密集颗粒群计算中，效率下降了30%，即原计算时长约为0.77s，现计算时长约1.1s，但保证了结果的精准性。
    经
颗粒接触：
    加入forceTraverse模块，用于测试Lattice算法的正确性
引力模块：
    现有引力模块可能有很多不太实用的地方，因此全部注释处理。
    但保留GravBody模块。
网格接触：
    保留原有bondedWall模块，其为四边形单元，可以与颗粒相互作用（即产生接触力的同时，可以根据接触力运动）
    增添trimeshWall模块，其为三角形单元，可以给颗粒系统提供接触力，自身的运动留待以后增加[注意经测试发现，trimeshWall会在连接处产生跳跃作用，因此将三角形单元设置为双面均可接触的类型，避免产生过大的跳跃力；同时设置edgeFlag，在连接处降低接触刚度]
    注意由于输入误差，会导致网格接触判断出现较大问题，因此初始化操作放在程序中进行，而非直接读入数据
    继续验证之后发现原有的网格搜索接触算法采用类重心坐标系计算，会在角边连接处出现接触量突变的情况，造成仿真失真，因此将其修改为垂线分割的方式。
    增添forceRotSystem模块，用于提供非惯性力，如离心力、科氏力等
    将planet模块与forceRotSystem模块统一，不再单设独立的参数入口，删去输入文件planetProperties.txt
benchmark:
    测试颗粒在trimeshWall上的滚动过程
    测试颗粒在多面体引力场周围的运动
    新加入测试文件，input_points_Lattice，可以测试超密集颗粒流时的程序运算；input_points_GravFlow，可以测试TriMesh的接触计算；
工具：
    加入genSphereTriMesh.m文件，用于生成均匀分布的近球形多面体网格
    加入genDEMBodyMesh.m文件，用于将mesh文件转换为DEMBody适用的mesh文件。
    更新genParticlesBox与genParticlesSphere函数
    加入Test文件夹，用于存放代码开发过程中的相关测试函数，目前包含pointTriMesh.m，测试空间三角形的最近点搜索；
    加入post-processing文件夹，用于存放后处理相关函数，目前包含addMovies.m，genWallPovRay.m，genPovRayMov.m，texture.m，asteroid.pov，Demo.pov；
*********************************************************************
DEMBody   4.1.1    29/9/2018上线

周期边界条件：
    测试了周期边界内颗粒受力与直接加镜像颗粒受力，发现两者无差别，证明该程序应该不存在问题。
    测试之后发现，如果颗粒A与颗粒B跨周期边界接触，则需要将接触信息存储下来，但是Traverse算法会强制搜索两者之间的接触，发现两者其实并未接触，则将会把接触信息删除，由此出现问题；
    直观的修改方案为将镜像颗粒信息存储标签+NMAX，但这样隐含一个问题，就是在跨周期边界接触时，颗粒可能过会儿就转换为非跨周期边界接触，此时应该将原有信息传输给此时的接触链表，但由于NMAX的存在，其并不会传递该信息，导致出现问题。
    因此在仔细思考之后，我认为如果采用Lattice算法就不会出现该问题，因此，结论为periodic与目前的traverse算法不能共存！！！【或者在Traverse算法加入一定的网格阈值判断，应该就可以避免这个问题，留待以后验证】
    测试通过Lattice算法版本的periodic算例，没有问题。
Planet非惯性力：
    重新检查了推导过程，没有问题。
    但将omiga更正为omega，并将Planet参数移入systemControl文件。
forceGravBody：
    重新检查了推导过程，没有问题。
benchmark:
    新加入测试文件，input_points_periodic_A.txt与input_points_periodic_B.txt，可以测试周期边界条件的正确性。
*********************************************************************
DEMBody   4.2    7/10/2018上线

邻居颗粒链表：
    在计算大范围的颗粒运动时，网格数目可能非常多，如果此时仍然采用数组存储将会导致有大量的内存空间浪费，因此将其更换为链表存储的方式，将测试计算正确性与效率。此步更改只涉及到latticeGenerate中的网格生成过程，以及forceLattice中的遍历方式，对受力计算并无影响。
链表存储优化：
    在测试之后发现该步消耗的时间急剧增加，可能是因为邻居链表的放入需要从头搜索到链表末端，因此十分消耗时间；但是考虑到本算法模块为串行执行，即每次都是放入到当前链表的末端，因此加入tailInner与tailOuter指针，用于存储当前链表的末端；放入新数据时直接放入链表末端即可。经过测试，此步运算速度增加了100倍。
    通过对latticeGenerate模块的测试，直接比较Array算法与末端加速Linklist算法生成的网格数据，发现两者生成的数据保持一致，因此证明该方法的正确性。
数据精准化：
    将程序中的常量均修改为双精度浮点数以提高精度。目前已经修改的有：forceLattice、forceTraverse、forceContactWall、intgrt。
程序精度：
    经过几天的研究之后发现，程序的误差扩散非常快，基本在150步之后即扩散至非常大的程度。检测系统的Head数据，发现并没有出现没有检测接触的情况，猜测这可能是因为N体系统的复杂性与混沌性导致的。【减小摩擦系数至非常小的时候误差扩散即会维持在非常小的范围内】
    将200步长后的颗粒信息作为初始条件，发现会在约150步出现时出现误差扩散，增加误差问题的可能性。
benchmark:
    新加入测试文件，input_points_denseLattice.txt为密集排布网格颗粒群，input_points_sparseLattice.txt为正常排布网格颗粒群，input_points_sandLattice.txt为正常排布网格颗粒群，同时其包含与地面的接触及形成沙堆的过程。
注意：
    此次更新留下了很多问题，将会在下个版本测试并确定最终版本。比如，对于邻居颗粒的存储，在下个版本将会直接删除；对于Head接触历史的搜索将会进行大幅度加速。
    同时此次更新造成了一个问题，即产生了两个forceLattice，一个版本为LinklistStore，一个版本为ArrayStore，将会在下个版本决定最终选用哪个。
*********************************************************************
DEMBody   4.3    8/10/2018上线

Head接触历史搜索：
    继续思考程序加速的问题，发现每次在搜索接触历史时需要从头遍历到最后，在链表较长的时候可能会出现搜索时间过长的问题；由于该部分的数据为顺序结构，即颗粒编号逐渐升高，每次搜索的起点不需要设置为链表头，直接放在上次搜索的末端即可。经测试使用该策略之后，程序由0.44s降为0.37s，效率提升约为1.2倍。
    已修改的模块有forceLattice、forceTraverse、forceMirror。
链表存储：
    实现运行过程中发现其实Array转换为Linklist并没有消耗太多时间，因此考虑将网格划分十分紧密，然后去掉邻居颗粒的存储，转而存储邻居网格的编号，直接进行搜索，这样即可消去大量的内存消耗【原有的邻居存储相当于把颗粒编号存储了27次，因而内存消耗非常巨大】。经测试使用该策略之后，sparseLattice的内存消耗由将近800M降低为约400M。
    但经过实际测试之后发现，在网格非常多的情形中，如仿真Pan形成的场景中，Lattice的消耗也非常大。
密集链表：
    由于程序目前更改为密集链表，即严格按照2.5Rmax来设置lattice，因此分配的邻居颗粒一定位于meshGenerate所得到的邻居网格内，因此该步骤的运算似乎失去了意义。将forceLattice中的该步骤判断删去后程序由0.37s加速到0.25s，即提升效率约1.5倍。
    屏蔽文件输出后加速至0.23s。
ParticleLattice：
    新加入ParticleLattice模块，使用ParticleLattice控制，其利用颗粒进行遍历搜索，可能适应于颗粒数目少于网格数目的情况，或适应于颗粒分布不均匀的情况。
    但是实际测试之后发现两种搜索方式的时间差不多，CPU占用率都大概在60%左右，目前尚不清楚问题在哪儿。最终发现屏蔽文件输出之后效率大幅度提升。
程序精准化：
    将程序中的常量均修改为双精度浮点数以提高精度。目前已经修改的有：forceLattice、forceTraverse、forceContactWall、intgrt、forceMirror、forceTriMeshWalls、forceGravBody、attitude、attitudeBondedWalls、attitudeBondedWallsQM、attitudeGravBody、forceGravBody。仅余forceBondedWalls与forceFunnelWalls。
综上，删除ArrayStore相关的模块，只保留LinklistStore。也不保存其对应的预编译指令。

关于周期边界条件：
    思考了一下觉得目前的周期性边界条件可能有问题，即搜索镜像粒子时只能找到上下左右四个网格的颗粒，而无法找到对角处的颗粒。
    同时周期性边界条件应该可以通过网格算法进行加速，即给每个网格加入镜像网格的链表，进行遍历即可。
    留待下个版本处理。
    同时发现当时的periodic中Tag算法也有问题，即不应该使用2*R做判据，应使用2.5*Rmax做判据。
*********************************************************************
DEMBody   4.3.1    10/10/2018上线

ParticleLattice：
    经过Pan文件的测试之后发现该函数有一定问题，即由于Lattice数据结构是在某几步过程中不变的，但是meshgrid在目前的架构下是每步更新的，这就造成了用颗粒位置算出来的Lattice序号可能与实际的序号不一致，因此将meshgrid同样挪入refreshLattice的控制之下。
LatticeGenerate:
    由于目前的mesh与lattice参数相同，因此将latticeGenerate中的网格序号计算修改为直接调用linklist。
    同时，根据Pan仿真中的经验，我们发现该步在大网格的时候计算量较大，尤其是在更新频率较高的时候该问题更为突出，因此尽量减少这一步的计算时间是比较重要的。注意到该步骤需要检测颗粒是否在网格之中，而这在某些问题中是不存在的，因此新加入Confined控制参数，用于控制是否判断其在网格内。【需谨慎使用该参数！！！】
    同时，由于目前并没有构造邻居颗粒的过程，Lattice%ID似乎并没有作用，因此直接删除；并在Confined情形中，删除对于网格位置的描述（由于nConfined中还需要比较与网格的位置关系）。
Planet：
    Planet的参数导入有误，更改为重新计算校核omega，但是留存了一个问题，即无法判定正负号；因此将其修改为利用输入参数确定正负号，再利用读取的半径算出角速度值。
    再次检查Planet函数运算，没有问题。
    再次检查GravBody函数运算，没有问题。
Periodic：
    之前版本的剪切边界条件应该有问题，即镜像颗粒的位移应该是gamma*LengthY，而不是0.5*gamma*LengthY；
    经过测试，发现新版本的程序可以很好地模拟shear boundary，并且解决了Pan仿真中颗粒远离星环层的问题。
控制台文件：
    给控制台文件加入了备注，之后可以根据备注直接调整程序。
Tool:
    发现了Tool文件夹的错误，即genParticles相关文件中的转动惯量计算错误，已修正。
