********************************************************************
该文件夹下用于程序开发相关版本。

即更新代码功能，上传Git，加入程序发布说明

相关的测试文件存储于BenchMark文件夹中，生成的动画存储于动画汇总中。
*********************************************************************
Git命令步骤

git status 查看修改；git add -A 添加修改至暂存区
git commit -m 添加修改至存储区； git push origin master 发布修改
*********************************************************************
DEMBody   2.0

加入编译预处理，其中包括NMAX设置，场景设置，接触类型选择，网格划分。
优化代码架构，分为src文件，存储源码与make file
                  input文件，存储输入信息
                  data文件，存储输出数据
使用程序需修改输入文件，修改makefile中的模型设置，修改system control。
*********************************************************************
DEMBody   2.0

加入BondedWall功能，当前版本仅有长方形单元，用于实现多面体的运动计算；
优化代码架构，加入tool文件夹，用于存储前、后处理相关程序，包括网格划分工具、
              加入Data/Wall文件夹，用于存储BondedWall的vtk文件（程序控制）。
*********************************************************************
DEMBody   3.0    27/3/2018上线

全新的网格搜索算法，在50万基准颗粒测试中提升效率一千倍。
增加benchmark基准测试输入与控制文件。
增加genMesh文件，用于辅助网格算法。
*********************************************************************
DEMBody   4.0    21/5/2018上线

引力模块：（仍需更新）
    加入自引力计算模块，使用makefile预处理self_gravity控制。
    修复了GravityLattice中的相关bug，精细化了引力计算过程，但效率有所降低。
    设置独立的引力计算步长、修正引力计算结果以提高效率与精确度（待完成）
    加入GravBody模块，用于生成中心小天体引力场以及接触受力，同时加入四元数描述
并行设置：
    修改了Lattice部分的算法，将其由数组转换为链表，大幅度提升了内存能力。（仍需更新）
    增加了对于Lattice更新的步长控制，考虑到颗粒移动速度与网格宽度，间隔几个步长之后再更新。（仍需更新）
    修复latticeGenerate中的相关bug；同时将其转为并行算法，牺牲了些许精度，但是大幅度提高了效率。
    修改了BodyForce的并行控制语言，大幅度提高了计算效率。
    减小了墙壁网格算法的阈值，由Dx => 0.8*Dx
其他：
    修改了颗粒对接触模型，在凝聚力区域增加正向阻尼力、切向阻尼力以及滚动阻尼力（暂未加），以提高接触强度。
    删除了颗粒对接触时，在凝聚力区域的相关作用力（即删除上个注释的工作），将模型修改为Jiang的最新模型，利用Beta、Mu与c描述系统。
    修改了periodic模型，以实现长方形的周期边界条件
后处理模块：
    加入Demo.pov，内置多种纹理
    更新genWallPOVRay.m，细化纹理操作与动画设置
加入ChangeLog.txt文件
加入Description.txt文件，以描述每次仿真的详细设置与所做出的源码修改，确保仿真工作的流程精细化。
*********************************************************************
DEMBody   4.1    25/9/2018上线

系统：
    调试通过Windows版本预编译指令，工程文件存入DEMBody文件夹，存储入git，以后可以直接使用该工程进行windows版本的调试。
    将forceLattice与forceTraverse的算法选择放入编译选项中设置；同时Lattice算法相关的函数也放入其中。
Lattice算法：
    测试稳定性，未发现问题，已解决【可能是时间步长设置问题】
    修改加速策略，参考ESyS-Particle，设置颗粒运动阈值，在颗粒运动范围超出限制后更新网格；注意经过测试发现并行确实会出现很多问题！！！【此加速策略要求，任何大范围的颗粒移动都需要网格刷新，因此运行周期边界之后需要更新网格！！！，此前Pan仿真的问题应该出在这个地方】
链表算法：
    链表算法存在较大问题，在跨网格时可能丢失接触信息，因此将压缩信息链表转换为全信息链表，即链表保存所有与其接触的颗粒数据；每次修改将对两条链表进行修改，但这样将会造成并行区域的问题，继续思考解决办法
    方案[1]：双链条读，单链条写，即写入接触信息原来存在的链表中，保证一定可以查阅到链条存储的相应信息，但是又不会存在双链条均有信息，找不到选取哪一条的情况；但是其实该方法还是存在并行问题，由于执行写入操作时有可能涉及到邻居网格的写入操作，影响到邻居颗粒链表，因而可能出现单个变量同时写入的情况！！！
        但经过分析之后发现，该情况只存在于HeadI没有HeadJ存在的情况，此时涉及到的操作只有修改或删除，其中修改无任何不良影响，而删除可能会影响其他网格的修改操作，即相邻线程同时在处理该颗粒的链表；这一修改操作包含修改（无影响）、增加（可能有影响，改变的节点位置相同）、删除（可能有影响，改变的节点位置相同）。
        若采用了verlet算法，由于网格更新的频率降低了，相当于发生这种错误的概率更加大大降低了。即必须为更新网格算法的同时，发生了颗粒更换接触顺序的情况，
    方案[2]：双链条读，单链条写，但是写入网格内颗粒对应的链条。此种方案显然可以保证并行写入时不会出现错误。但面临一个新的问题，即如何判断哪一个链条获得信息是正确的，一种简单的方法即是将时间信息保存在接触链表之中；如果该信息为上一时刻，那么即为最新的信息。总结一下，即为读取信息从两条链表中找到最新的，写入链表的时候只操作particleI对应的链表。
    经过测试，方案[1]与方案[2]均可实现较长时间的计算稳定，最终选择方案[2]作为解决方案（1000步运算之后，3000颗粒的受力误差和不超过0.2）。
    再次发现问题：读取的时候也可能出现别的线程正好在更新链表的情况。因此应尽可能减小访问其他单元内的链表信息，即particleJ的信息。设置如下措施，[1]，若particleI链表中已访问到数据，则不访问particleJ链表；[2]，颗粒脱离时不删除数据，只将其从链表节点中删除(可能会有很大的问题，后续将修改为双链表分离操作！！！)
    最终方案：经过仔细研究与测试，我们发现采用现行的半搜索方案可能无法处理线程冲突的问题，而之前的经验告诉我们设置critical区的效率非常低，因此最终采用全搜索的方式。
    全搜索链表：将LatticeGenerate算法修改为全邻居颗粒产生；同时forceLattice中计算受力只更新particleI，同时去除reduction。
    经input_points_Lattice测试发现新的Lattice算法在30万超密集颗粒群计算中，效率下降了30%，即原计算时长约为0.77s，现计算时长约1.1s，但保证了结果的精准性。
    经
颗粒接触：
    加入forceTraverse模块，用于测试Lattice算法的正确性
引力模块：
    现有引力模块可能有很多不太实用的地方，因此全部注释处理。
    但保留GravBody模块。
网格接触：
    保留原有bondedWall模块，其为四边形单元，可以与颗粒相互作用（即产生接触力的同时，可以根据接触力运动）
    增添trimeshWall模块，其为三角形单元，可以给颗粒系统提供接触力，自身的运动留待以后增加[注意经测试发现，trimeshWall会在连接处产生跳跃作用，因此将三角形单元设置为双面均可接触的类型，避免产生过大的跳跃力；同时设置edgeFlag，在连接处降低接触刚度]
    注意由于输入误差，会导致网格接触判断出现较大问题，因此初始化操作放在程序中进行，而非直接读入数据
    继续验证之后发现原有的网格搜索接触算法采用类重心坐标系计算，会在角边连接处出现接触量突变的情况，造成仿真失真，因此将其修改为垂线分割的方式。
    增添forceRotSystem模块，用于提供非惯性力，如离心力、科氏力等
    将planet模块与forceRotSystem模块统一，不再单设独立的参数入口，删去输入文件planetProperties.txt
benchmark:
    测试颗粒在trimeshWall上的滚动过程
    测试颗粒在多面体引力场周围的运动
    新加入测试文件，input_points_Lattice，可以测试超密集颗粒流时的程序运算；input_points_GravFlow，可以测试TriMesh的接触计算；
工具：
    加入genSphereTriMesh.m文件，用于生成均匀分布的近球形多面体网格
    加入genDEMBodyMesh.m文件，用于将mesh文件转换为DEMBody适用的mesh文件。
    更新genParticlesBox与genParticlesSphere函数
    加入Test文件夹，用于存放代码开发过程中的相关测试函数，目前包含pointTriMesh.m，测试空间三角形的最近点搜索；
    加入post-processing文件夹，用于存放后处理相关函数，目前包含addMovies.m，genWallPovRay.m，genPovRayMov.m，texture.m，asteroid.pov，Demo.pov；
*********************************************************************
DEMBody   4.1.1    29/9/2018上线

周期边界条件：
    测试了周期边界内颗粒受力与直接加镜像颗粒受力，发现两者无差别，证明该程序应该不存在问题。
    测试之后发现，如果颗粒A与颗粒B跨周期边界接触，则需要将接触信息存储下来，但是Traverse算法会强制搜索两者之间的接触，发现两者其实并未接触，则将会把接触信息删除，由此出现问题；
    直观的修改方案为将镜像颗粒信息存储标签+NMAX，但这样隐含一个问题，就是在跨周期边界接触时，颗粒可能过会儿就转换为非跨周期边界接触，此时应该将原有信息传输给此时的接触链表，但由于NMAX的存在，其并不会传递该信息，导致出现问题。
    因此在仔细思考之后，我认为如果采用Lattice算法就不会出现该问题，因此，结论为periodic与目前的traverse算法不能共存！！！【或者在Traverse算法加入一定的网格阈值判断，应该就可以避免这个问题，留待以后验证】
    测试通过Lattice算法版本的periodic算例，没有问题。
Planet非惯性力：
    重新检查了推导过程，没有问题。
    但将omiga更正为omega，并将Planet参数移入systemControl文件。
forceGravBody：
    重新检查了推导过程，没有问题。
benchmark:
    新加入测试文件，input_points_periodic_A.txt与input_points_periodic_B.txt，可以测试周期边界条件的正确性。
*********************************************************************
DEMBody   4.2    7/10/2018上线

邻居颗粒链表：
    在计算大范围的颗粒运动时，网格数目可能非常多，如果此时仍然采用数组存储将会导致有大量的内存空间浪费，因此将其更换为链表存储的方式，将测试计算正确性与效率。此步更改只涉及到latticeGenerate中的网格生成过程，以及forceLattice中的遍历方式，对受力计算并无影响。
链表存储优化：
    在测试之后发现该步消耗的时间急剧增加，可能是因为邻居链表的放入需要从头搜索到链表末端，因此十分消耗时间；但是考虑到本算法模块为串行执行，即每次都是放入到当前链表的末端，因此加入tailInner与tailOuter指针，用于存储当前链表的末端；放入新数据时直接放入链表末端即可。经过测试，此步运算速度增加了100倍。
    通过对latticeGenerate模块的测试，直接比较Array算法与末端加速Linklist算法生成的网格数据，发现两者生成的数据保持一致，因此证明该方法的正确性。
数据精准化：
    将程序中的常量均修改为双精度浮点数以提高精度。目前已经修改的有：forceLattice、forceTraverse、forceContactWall、intgrt。
程序精度：
    经过几天的研究之后发现，程序的误差扩散非常快，基本在150步之后即扩散至非常大的程度。检测系统的Head数据，发现并没有出现没有检测接触的情况，猜测这可能是因为N体系统的复杂性与混沌性导致的。【减小摩擦系数至非常小的时候误差扩散即会维持在非常小的范围内】
    将200步长后的颗粒信息作为初始条件，发现会在约150步出现时出现误差扩散，增加误差问题的可能性。
benchmark:
    新加入测试文件，input_points_denseLattice.txt为密集排布网格颗粒群，input_points_sparseLattice.txt为正常排布网格颗粒群，input_points_sandLattice.txt为正常排布网格颗粒群，同时其包含与地面的接触及形成沙堆的过程。
注意：
    此次更新留下了很多问题，将会在下个版本测试并确定最终版本。比如，对于邻居颗粒的存储，在下个版本将会直接删除；对于Head接触历史的搜索将会进行大幅度加速。
    同时此次更新造成了一个问题，即产生了两个forceLattice，一个版本为LinklistStore，一个版本为ArrayStore，将会在下个版本决定最终选用哪个。
*********************************************************************
DEMBody   4.3    8/10/2018上线

Head接触历史搜索：
    继续思考程序加速的问题，发现每次在搜索接触历史时需要从头遍历到最后，在链表较长的时候可能会出现搜索时间过长的问题；由于该部分的数据为顺序结构，即颗粒编号逐渐升高，每次搜索的起点不需要设置为链表头，直接放在上次搜索的末端即可。经测试使用该策略之后，程序由0.44s降为0.37s，效率提升约为1.2倍。
    已修改的模块有forceLattice、forceTraverse、forceMirror。
链表存储：
    实现运行过程中发现其实Array转换为Linklist并没有消耗太多时间，因此考虑将网格划分十分紧密，然后去掉邻居颗粒的存储，转而存储邻居网格的编号，直接进行搜索，这样即可消去大量的内存消耗【原有的邻居存储相当于把颗粒编号存储了27次，因而内存消耗非常巨大】。经测试使用该策略之后，sparseLattice的内存消耗由将近800M降低为约400M。
    但经过实际测试之后发现，在网格非常多的情形中，如仿真Pan形成的场景中，Lattice的消耗也非常大。
密集链表：
    由于程序目前更改为密集链表，即严格按照2.5Rmax来设置lattice，因此分配的邻居颗粒一定位于meshGenerate所得到的邻居网格内，因此该步骤的运算似乎失去了意义。将forceLattice中的该步骤判断删去后程序由0.37s加速到0.25s，即提升效率约1.5倍。
    屏蔽文件输出后加速至0.23s。
ParticleLattice：
    新加入ParticleLattice模块，使用ParticleLattice控制，其利用颗粒进行遍历搜索，可能适应于颗粒数目少于网格数目的情况，或适应于颗粒分布不均匀的情况。
    但是实际测试之后发现两种搜索方式的时间差不多，CPU占用率都大概在60%左右，目前尚不清楚问题在哪儿。最终发现屏蔽文件输出之后效率大幅度提升。
程序精准化：
    将程序中的常量均修改为双精度浮点数以提高精度。目前已经修改的有：forceLattice、forceTraverse、forceContactWall、intgrt、forceMirror、forceTriMeshWalls、forceGravBody、attitude、attitudeBondedWalls、attitudeBondedWallsQM、attitudeGravBody、forceGravBody。仅余forceBondedWalls与forceFunnelWalls。
综上，删除ArrayStore相关的模块，只保留LinklistStore。也不保存其对应的预编译指令。

关于周期边界条件：
    思考了一下觉得目前的周期性边界条件可能有问题，即搜索镜像粒子时只能找到上下左右四个网格的颗粒，而无法找到对角处的颗粒。
    同时周期性边界条件应该可以通过网格算法进行加速，即给每个网格加入镜像网格的链表，进行遍历即可。
    留待下个版本处理。
    同时发现当时的periodic中Tag算法也有问题，即不应该使用2*R做判据，应使用2.5*Rmax做判据。
*********************************************************************
DEMBody   4.3.1    10/10/2018上线

ParticleLattice：
    经过Pan文件的测试之后发现该函数有一定问题，即由于Lattice数据结构是在某几步过程中不变的，但是meshgrid在目前的架构下是每步更新的，这就造成了用颗粒位置算出来的Lattice序号可能与实际的序号不一致，因此将meshgrid同样挪入refreshLattice的控制之下。
LatticeGenerate:
    由于目前的mesh与lattice参数相同，因此将latticeGenerate中的网格序号计算修改为直接调用linklist。
    同时，根据Pan仿真中的经验，我们发现该步在大网格的时候计算量较大，尤其是在更新频率较高的时候该问题更为突出，因此尽量减少这一步的计算时间是比较重要的。注意到该步骤需要检测颗粒是否在网格之中，而这在某些问题中是不存在的，因此新加入Confined控制参数，用于控制是否判断其在网格内。【需谨慎使用该参数！！！】
    同时，由于目前并没有构造邻居颗粒的过程，Lattice%ID似乎并没有作用，因此直接删除；并在Confined情形中，删除对于网格位置的描述（由于nConfined中还需要比较与网格的位置关系）。
Planet：
    Planet的参数导入有误，更改为重新计算校核omega，但是留存了一个问题，即无法判定正负号；因此将其修改为利用输入参数确定正负号，再利用读取的半径算出角速度值。
    再次检查Planet函数运算，没有问题。
    再次检查GravBody函数运算，没有问题。
Periodic：
    之前版本的剪切边界条件应该有问题，即镜像颗粒的位移应该是gamma*LengthY，而不是0.5*gamma*LengthY；
    经过测试，发现新版本的程序可以很好地模拟shear boundary，并且解决了Pan仿真中颗粒远离星环层的问题。
控制台文件：
    给控制台文件加入了备注，之后可以根据备注直接调整程序。
Tool:
    发现了Tool文件夹的错误，即genParticles相关文件中的转动惯量计算错误，已修正。
*********************************************************************
DEMBody   4.3.2    11/10/2018上线

多面体引力：
	加入多面体引力模块。算法核心为生成网格，预先计算网格节点处的引力，再通过六面体插值方法计算具体引力。
	利用控制参数isGravTriMesh控制，新构建GravTriMeshLattice，使其保存网格中心点位置与节点编号；initSystem读取引力场数据并设置网格参数。
	同步修改makefile与makefileWin
*********************************************************************
DEMBody   4.3.3    18/10/2018上线

近地交会潮汐力设计思路：
	在近地交会的算例中，需要在本体系下计算表层颗粒的流动，因此需要计算相关的非惯性力，其中一项为小行星转动状态改变引起的非惯性力，因此需要计算小行星在飞跃过程中收到的1.颗粒产生的作用力与力矩；2.行星产生的作用力与力矩（通过球谐函数计算）。
YORP加速形状演化设计思路：
	小行星（即TriMesh）保持恒定加速；表层物质在小行星引力场与离心力作用下运动。
YORP加速南极石块运动设计思路：
	小行星（即TriMesh）保持恒定加速；表层物质在小行星引力场与离心力作用下运动；南极石块使用BondedMesh提供接触力，所受引力利用若干个质点球代替。

自引力：
	删除自引力相关的程序。
程序结构：
	更改命令行界面；
	使用force.f90函数统一目前加入的所有受力计算模块。
BondedWall:
	修改0:0.8Dx为-0.8Dx:0.8Dx；
	加入edgeFlag对面、边、角处接触力的计算进行修正；
	加入凝聚力（接触型凝聚力）；
TriMeshWall:
	加入凝聚力（接触型凝聚力）；
Tool:
	新建mesh文件夹，存储网格处理相关函数包。
	修改genSphereTriMesh，使其兼容VTK格式文件与BT格式文件。
	修改genDEMBodyMesh，使其兼容VTK格式文件。
	加入loadVTK与writeVTK文件，约定以后的网格数据均通过VTK格式相互联系。
	加入writeBT文件，用于与多面体引力程序相互联系。
	加入Polyhedron程序包，用于生成.polyhedron文件；加入PolyhedronGravity程序包，用于生成多面体引力场。
Tool文件的数据格式问题：
	在该版本中新加入了很多数据处理文件，因此进行一定的约定与梳理。统一规定如下：
	.vtk文件作为后处理的核心文件格式，通过loadVTK与writeVTK进行交互；.bt、.polyhedron、.volume为多面体引力场程序的格式；.force存储引力场预处理得到的引力信息；.mesh文件为网格数据初始化信息。
*********************************************************************
DEMBody   4.4    22/10/2018上线

系统优化：
	继续约定文件格式，系统控制文件采用.dembody，trimesh数据采用.mesh，gravTriMesh数据采用.force，bondedWall数据采用.vtk。
网格算法：
	现有的网格算法，使用全部网格对所有颗粒进行搜索，则算法效率十分低，160万颗粒与440三角面元耗时将近40秒，因此考虑采用将三角面元分布至网格内的算法（类似于分配颗粒到网格中），可以大幅度降低计算耗时。
	注意当前加入的算法仅适用于静态三角面元。
	采用长方体包络的方式求出可能与三角面元产生接触的网格序号，在颗粒遍历时，只需搜索其对应的网格内的三角面元即可。在分配网格时，通过遍历三角面元，检查其邻居网格，并将其分配至网格结构中；因此，网格内存储的面元序号列表为顺序结构，因此查找接触历史时同样可以利用直接搜索末尾的技巧来加速程序。
	面元网格分配算法已通过文件测试。测试结果发现网格内面元最多为11个，总共网格内面元数约30万，而网格内颗粒数约为10个，则计算量约为300万。设置网格阈值后，即靠近平面2.0Dx的网格，面元最多为7个，总共网格内面元数约10万，则总计算量约为100万。
	实际测试结果表明，在使用长方体包络的方法后，程序由将近40s加速至0.1s；如果再在长方体包络的基础上进行筛选，即只考虑离面元较近的网格，则程序由将近0.1s变为0.1s，说明可能该步骤没有什么作用。。。但是将DYNAMIC改为GUIDED之后，程序变为将近0.01s。
*********************************************************************
DEMBody   4.4.1    22/10/2018上线

Head链表：
	目前来看Head链表的接触时间记录没有作用，因此将其删去。
输入文件：
	考虑到目前mesh参数与Lattice参数相同，因此将其梳理后，统一为Lat_相关参数；
	将引力设为三维数据；
Output：
	精简Output文件，删去Head接触历史文件中时间记录信息，使用historyOutput控制是否输出；
OpenMP：
	经过天河上的测试发现，在大规模的颗粒计算中，使用GUIDED模式比DYNAMIC模式速度更快，因此将计算规模较大的函数全部更改为GUIDED模式。注意，之前的经验表明，此模式的选择具有很大的不确定性，因此尽量每次运行程序之前可以先行运行多组数据，找出较优的模式。【同时，需要指出的是，一开始的Loose Packing不能反映Dense Packing时的运行状态】
断点重续计算：
	将Force文件改为RestartData.txt，并设置Time、Tnext、Step、CheckPointTnext即可。
接触模型：
	forceMirror中有正向切向力，滚动摩阻，凝聚力；
	ContactWall中有正向切向力，滚动摩阻，无凝聚力；
	forceBondedWalls中有正向切向力，无滚动摩阻，有凝聚力；
	forceTriMeshWalls中有正向切向力，有滚动摩阻，有凝聚力；
	forceFunnelWalls中有正向切向力，有滚动摩阻，无凝聚力；
	forceGravBody中有正向切向力，有滚动摩阻，有凝聚力。
*********************************************************************
DEMBody   4.5    22/10/2018上线

架构：
    加入版本号常量，在系统初始化时校验，以判断是否采用了统一的计算程序与输入文件。
    之后的文件必须保证输入文件的版本与计算引擎的版本保持匹配。
BondedTrimeshWall:
    加入新特性-BondedTrimeshWall，可以输出TrimeshWall所受到的力与力矩，但是本程序不进行BondedTrimesh的姿态与运动积分，留给Bennu等研究中进行特例化。【需要注意的是，由于本版本的BondedTriMeshWall不考虑其运动，因此直接使用本体系下的坐标进行受力计算，在之后的版本中应想办法解决该问题】
    该特性使用isBondedTrimeshWall控制，需要.dembody文件中定义惯性系下的位置、速度、角速度、姿态，以及质量、转动惯量等信息，同时需指明面元数目；网格输入文件为bondedTriMeshWall.mesh
    在Output文件中加入bondedTriMeshWalls的输出。
    通过测试！
    加入相应的makefile命令
*********************************************************************
DEMBody   4.6    22/10/2018上线

BondedWall:
    将所有的四元数与姿态矩阵的转换统一为attitudeQ2M子例行程序。同时修改对应的makefile。
Tool：
    新加入Fortran版本的多面体处理文件，由于部分采用了四精度浮点数，该版本的数据更为精确。其中preload程序读取多面体.bt数据，其格式要求与C版本完全相同；gravity程序计算多面体产生的引力势。在使用时需要修改密度数据，同时gravity程序被封装为PolyhedronGravity模块，直接集成在DEMBody程序包中。
    规范loadVTK、writeVTK、writeBT，均为直接读取、写入，其中loadVTK得到的点源数据为0开头，因此需要+1；writeVTK写入数据也需要先-1转换为0开头编号；writeBT写入数据同样需要-1转换为0开头。
    规范genDEMBodyMesh.m，使之与load、write文件适配；同时修改其中的错误，并在每次生成数据之前，进行面元法向量的校核。
    增加函数genGravTriMesh.m，用于生成引力多面体所需的网格节点。
    增加函数scaleMesh.m，用于缩放多面体网格。
常数更新：
    规范目前所有程序中采用的常数，包括万有引力常数，采用Nature文章的最新结果6.674184e-11。
*********************************************************************
DEMBody   5.0    5/12/2018上线

ContactModel:
    经过实际测试发现，原有的“精细处理”会导致系统动能很长时间不能耗散到较小程度，因此，在此版本中，去除所有接触中的精细处理，并在存储接触历史时只存储弹性接触，删去阻尼接触的部分。目前已完成：forceParticleLattice、forceLattice、forceTraverse、forceMirror、forceContactWalls、forceBondedWalls、forceTriMeshWalls、forceBondedTriMeshWalls、forceFunnelWalls、forceGravBody。
能量梳理：
    检查原有的弹性能计算过程，该步骤只考虑正向弹性势能，不考虑切向与滚动、扭转方向的弹性能。对于颗粒间接触，表达式为0.2D0*Kn*(Dn**2)；对于颗粒与墙壁接触，表达式为0.4D0*Kn*(Dn**2)；对于颗粒与动墙壁接触，表达式为0.2D0*Kn*(Dn**2)。【即可以运动的能量均分，不能运动的能量全算在可以运动的物体上】
    加入摩擦能概念，用于存储颗粒摩擦产生的摩擦能。计算方法为：若颗粒间没有发生相对滑动，则没有摩擦能；若颗粒间发生相对滑动，则根据两者的相对位移计算，同时认为两者热导率相同，即0.5*f*dl；注意，对于不能移动的物体，同样考虑两个方向的传导，即计算公式还为0.5*f*dl。在此版本中，加入三种热能，Heat(1)为摩擦热能，Heat(2)为滚动摩阻热能，Heat(3)为扭动摩阻热能。
    在Output函数中加入Heat的输出。
forceBondedWall：
    新加入rolling与twisting摩阻，同时注意，在施加力与力矩时，均乘以edgeFlag以保证多个接触时没有多计算，能量计算也需此系数。【对于可能计算多次接触的模块，均考虑了edgeFlag。】
系统：
    加入Linux与Windows的编译指令，用于控制输出文件的系统命令选择。
    对全系统的检查校核。
forceSphereBody：
    新加入SphereBody的特性，用于计算多个孤立颗粒的受力。
    不考虑颗粒之间的相互作用，不考虑颗粒受到的墙壁作用力，但考虑SphereBody所受的环境里，这里只加入了重力。
    默认加入的spherebody比较少，不需要采用并行计算。
    测试通过！
姿态算法：
    原有姿态算法未考虑四元数的二阶项，在此版本加入。
    注意，更新姿态之后才能更新角速度！！！因为更新姿态时需要用到当前的角速度信息。
    测试通过！
Tool:
    更新原有的颗粒生成程序。
    修改Box的生成域，使其更容易使用。
    加入Stripe的颗粒纹理。
*********************************************************************
DEMBody   5.1    5/12/2018上线

forceRubblePile:
    新加入RubblePile模块，考虑RubblePile颗粒内部的引力、接触；外部颗粒与RubblePile的引力、接触。
